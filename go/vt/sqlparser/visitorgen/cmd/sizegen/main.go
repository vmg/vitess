package main

import (
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"os"

	"vitess.io/vitess/go/exit"
	"vitess.io/vitess/go/vt/log"
	"vitess.io/vitess/go/vt/sqlparser/visitorgen"
)

var (
	inputPackage = flag.String("input", "/home/vmg/src/vitess/go/vt/vtgate/engine/", "input package")
	outputFile   = flag.String("output", "test.go", "output file")
	compare      = flag.Bool("compareOnly", false, "instead of writing to the output file, compare if the generated visitor is still valid for this ast.go")
)

const enginePackage = "engine"

const usage = `Usage of visitorgen:

go run /path/to/visitorgen/main -input=/path/to/ast.go -output=/path/to/rewriter.go
`

func main() {
	defer exit.Recover()
	flag.Usage = printUsage
	flag.Parse()

	if *inputPackage == "" || *outputFile == "" {
		printUsage()
		exit.Return(1)
	}

	fs := token.NewFileSet()
	pkgMap, err := parser.ParseDir(fs, *inputPackage, nil, parser.AllErrors)
	if err != nil {
		log.Error(err)
		exit.Return(1)
	}

	enginepkg, ok := pkgMap["engine"]
	if !ok {
		log.Errorf("failed to find 'engine' package in path")
		exit.Return(1)
	}

	srcfile := visitorgen.Walk(fs, enginepkg)
	fmt.Printf("%s", srcfile)
}

func printUsage() {
	os.Stderr.WriteString(usage)
	os.Stderr.WriteString("\nOptions:\n")
	flag.PrintDefaults()
}

const fileHeader = `// Code generated by visitorgen/main/main.go. DO NOT EDIT.

package sqlparser

//go:generate go run ./visitorgen/main -input=ast.go -output=rewriter.go

import (
	"reflect"
)

type replacerFunc func(newNode, parent SQLNode)

// application carries all the shared data so we can pass it around cheaply.
type application struct {
	pre, post ApplyFunc
	cursor    Cursor
}
`

const applyHeader = `
// apply is where the visiting happens. Here is where we keep the big switch-case that will be used
// to do the actual visiting of SQLNodes
func (a *application) apply(parent, node SQLNode, replacer replacerFunc) {
	if node == nil || isNilValue(node) {
		return
	}

	// avoid heap-allocating a new cursor for each apply call; reuse a.cursor instead
	saved := a.cursor
	a.cursor.replacer = replacer
	a.cursor.node = node
	a.cursor.parent = parent

	if a.pre != nil && !a.pre(&a.cursor) {
		a.cursor = saved
		return
	}

	// walk children
	// (the order of the cases is alphabetical)
	switch n := node.(type) {
	case nil:
	`

const fileFooter = `
	default:
		panic("unknown ast type " + reflect.TypeOf(node).String())
	}

	if a.post != nil && !a.post(&a.cursor) {
		panic(abort)
	}

	a.cursor = saved
}

func isNilValue(i interface{}) bool {
	valueOf := reflect.ValueOf(i)
	kind := valueOf.Kind()
	isNullable := kind == reflect.Ptr || kind == reflect.Array || kind == reflect.Slice
	return isNullable && valueOf.IsNil()
}`
